#!/bin/bash
#
# pve: commandline Proxmox Virtual Environment interface

CFG=~/.pve-find.ini
SW="jq curl socat xtigervncviewer awk"
CACHE=~/.pve-cache

declare -A COOKIE
declare -A TOKEN
TIMEOUT=1
# Login session time cache
SESSION=300
# Named indices for found information on vm
readonly R_CLUS=0 R_HOST=1 R_ID=2 R_VM=3 R_TYPE=4 R_STATE=5

# CURL <cluster> "extra args"
CURL() {
   local CMD; local data; local cookie; local token; local cache; local age
   local age
   local now; local cluster; local ret
   #CMD="curl -m $TIMEOUT --fail --silent --insecure -D/dev/null"
   CMD="curl --fail --insecure -D/dev/null"
   test "$verbose" -eq 0 && CMD="$CMD --silent"

   local cluster="$1"
   shift

   chmod 600 "$CACHE"
   test -e "$CACHE" && cache="$(grep -m 1 ^$cluster$'\t' $CACHE)"
   if test "$cache" != ""; then
      message 2 "$cluster: Login cookie in cache."
      now=$(date "+%s")
      age=$(echo "$cache" | cut -d$'\t' -f 2)
      #message 1 "$cluster: ${now}_ _${age}_"
      if test "$(( now - age ))" -lt "$SESSION"; then
         message 2 "$cluster: Already logged in."
         token="$(echo "$cache" | cut -d$'\t' -f 3)"
         cookie="$(echo "$cache" | cut -d$'\t' -f 4- )"
      else
         flock -x -w 2 "$CACHE" sed -i "/^$cluster\t/d" "$CACHE"
         message 1 "$cluster: Cache invalid."
      fi
   fi

   if test "$cookie" = ""; then
      message 1 "$cluster: Logging in."
      data=$($CMD -d @<(cat <<<"username=${user[$cluster]}&password=${password[$cluster]}")  https://${hostname[$cluster]}:8006/api2/json/access/ticket 2> /dev/null)
      ret=$?
      test $ret -eq 7 && { message -1 "${hostname[$cluster]}: Failed to connect."; exit 1; }
      test $ret -eq 28 && { message -1 "${hostname[$cluster]}: Timed out."; exit 1; }
      test "$data" = "${data/ticket/}" && { message -1 "${hostname[$cluster]}: Unable to login."; exit 1; }
      cookie=$(echo $data | jq --raw-output '.data.ticket' | sed 's/^/PVEAuthCookie=/')
      token=$(echo $data | jq --raw-output '.data.CSRFPreventionToken')
      flock -x -w 2 "$CACHE" echo -e "$cluster\t$(date '+%s')\t$token\t$cookie" >> "$CACHE"
   fi
   $CMD --header "CSRFPreventionToken:$token" --cookie "$cookie" https://${hostname[$cluster]}:8006/api2/json/$*
   return $?
}

usage() {
   echo "Usage: pve <options> command"
   echo "Runs command over multiple nodes/clusters on containers and VM's."
   echo
   echo "  -v      Be more verbose (increase every time option is used)."
   echo "  -x      Debug mode enable."
   echo
   echo "  status <vm name>|<vmid>@cluster           Shows status of vm."
   echo "  start <vm name>|<vmid>@cluster            Start vm."
   echo "  shutdown <vm name>|<vmid>@cluster         Shutdown vm."
   echo "  stop <vm name>|<vmid>@cluster             Force stop vm."
   echo "  stat <vm name>|<vmid>@cluster <interval>  Show vm statistics every interval times (defaults to 1)."
   echo "  createct <ct name>@cluster "
  
   exit 1
}

parse_config() {
   while IFS='= ' read var val
   do
      if [[ $var == \[*] ]]
      then
          section=${var:1:-1}
      elif [[ $val ]]
      then
          declare -g -A "$var[$section]=$val"
      fi
   done < <(grep -v "^#" $CFG)
}

action() {
   cluster=$1

   #CURL="curl -m $TIMEOUT -f -s -k"
   CURL="curl  -f -s -k"

   test $verbose -eq 1 && echo "${hostname[$cluster]}: Connecting."
   data=$($CURL -d @<(cat <<<"username=${user[$cluster]}&password=${password[$cluster]}")  https://${hostname[$cluster]}:8006/api2/json/access/ticket)
   ret=$?
   test $ret -eq 7 && { test $verbose -eq 1 && echo "${hostname[$cluster]}: Failed to connect."; exit 1; }
   test $ret -eq 28 && { test $verbose -eq 1 && echo "${hostname[$cluster]}: Timed out."; exit 1; }
   test "$data" = "${data/ticket/}" && { echo "${hostname[$cluster]}: Unable to login."; exit 1; }

   cookie=$(echo $data | jq --raw-output '.data.ticket' | sed 's/^/PVEAuthCookie=/')
   token="CSRFPreventionToken: $(echo $data | jq --raw-output '.data.CSRFPreventionToken')"

   CURL="$CURL -S -b $cookie"

   # port remains open for about 10 seconds
   curl -s -D/dev/stderr -k -H "$token" -b "$cookie" -XPOST https://${hostname[$cluster]}:8006/api2/json/nodes/avon/qemu/200/vncproxy | jq .
   xtigervncviewer avon:5900
}

message() {
   local level=$1
   local msg="$2"
   if test "$level" -lt 0; then
      ( >&2 echo "$msg" ) > /dev/null 
   else
      test "$verbose" -ge "$level" && ( >&2 echo "$msg" ) > /dev/null 
   fi
}

find_name() {
   cluster=$1
   name=$2
   local nodes; local node; local data; local result

   unset clause
   #test $active -eq 1 && clause="and .status == \"running\""

   nodes=$(CURL $cluster nodes/ | jq -r ".data[] | .node")
   for node in $nodes
   do
      data="$(CURL $cluster nodes/$node/lxc/) $(CURL $cluster nodes/$node/qemu/)"
      result=$(echo $data | jq -r ".data[] | select((.name  | contains(\"$name\")) $clause) | \"$node \(.vmid) \(.name) \(.type // \"qemu\") \(.status)\"")
      if test "$result" != ""; then
         echo "$cluster $result"
      fi
   done
}

sanity_check() {
   err=0

   ! test -f $CFG && { echo "No config file found ($CFG)."; err=1; }

   test $err -eq 0 && test $(stat -c %a $CFG) -gt 600 && { echo "Unsafe permissions on config file."; err=1; }

   for name in $SW
   do
      if ! which $name > /dev/null 2>&1
      then
         missing="$missing $name"
         err=1
      fi
   done
   test "$missing" != "" && echo "Missing required software to run script:$missing"

   test $# -lt 1 && { echo "At least one argument required."; err=1; }

   test $err -ne 0 && usage
}

parse_options() {
   while getopts :igcvx opt; do
      case $opt in
         v) verbose=$(( verbose + 1 ))
         ;;
         c) connect=1
         ;;
         g) graphical=1
         ;;
         i) active=0
         ;;
         x) set -x
         ;;
         \?) echo "Unknowing options: -$OPTARG"
             usage
         ;;
      esac
   done
}

vnc() {
   server=$1
   type=$2
   vmid=$3
   test $verbose -eq 1 && echo "Connecting to server $server for $name..."

   port=$((netstat -atn | awk '{printf "%s\n%s\n", $4, $4}' | grep -oE '[0-9]*$'; seq 32768 61000) | sort -n | uniq -u | head -n 1)
   socat TCP-LISTEN:$port,bind=127.0.0.1 exec:"ssh root@$server qm vncproxy $vmid" &
   xtigervncviewer localhost:$port
}

clus_find_name() {
   local line
   local cluster
   local ret
   local vnname="$1"

   result=()
   # Check for id@cluster notation
   if test "${vmname/@/}" != "$vmname"; then
      cluster="${vmname/*@/}"
      id="${vmname/@*/}"
      nodes=$(CURL $cluster nodes/ | jq -r ".data[] | .node")
      for node in $nodes; do
         data="$(CURL $cluster nodes/$node/lxc/) $(CURL $cluster nodes/$node/qemu/)"
         res=$(echo $data | jq -r ".data[] | select(.vmid==\"$id\") | \"$node \(.vmid) \(.name) \(.type // \"qemu\") \(.status)\"")
         test "$res" != "" && result+=( "$cluster $res" )
      done
   else
      while read line; do
         if test "${line:0:1}" = "#"; then
            ret=( ${line:1} )
         else if test "$line" != ""; then
               result+=( "$line" )
            fi
         fi
      done < <( for cluster in ${!hostname[*]}; do
                   find_name $cluster $vmname & 
                   pids+=( $! )
                done 
                ret=0
                for pid in ${pids[*]}; do
                   wait $pid
                   ret=$(( ret + $? ))
                done
                echo "#$ret"
              )
      return $ret
   fi
}

vm_action() {
   local action="$1"
   local vmname="$2"

   clus_find_name "$vmname"
   test "${#result[*]}" = 0 && { echo "No matches found."; exit 1; }
   test "${#result[*]}" -gt 1 && { echo "More than one match found."; exit 1; }
   res=( ${result[0]} )
   CURL ${res[$R_CLUS]} nodes/${res[$R_HOST]}/${res[$R_TYPE]}/${res[$R_ID]}/status/$action -XPOST > /dev/null
   test "$?" -ne "0" && message -1 "Unable to $action $vmname"
   return 0
}

# Try and see if we can open a websocket and use it as a terminal
#
# https://git.proxmox.com/?p=pve-xtermjs.git;a=blob;f=src/www/main.js;h=62ec1c1846dc2cccd39ae3cbe5f7345ac74e58ed;hb=refs/heads/master
# https://gist.github.com/htp/fbce19069187ec1cc486b594104f01d0
#
# socketURL = protocol + location.hostname + ((location.port) ? (':' + location.port) : '') + '/api2/json' + url + '/vncwebsocket?port=' + port + '&vncticket=' + encodeURIComponent(ticket);
#
vm_terminal() {
   local vmname="$1"

   clus_find_name "$vmname"
   test "${#result[*]}" = 0 && { echo "No matches found."; exit 1; }
   test "${#result[*]}" -gt 1 && { echo "More than one match found."; exit 1; }
   res=( ${result[0]} )
   data="$(CURL ${res[$R_CLUS]} nodes/${res[$R_HOST]}/${res[$R_TYPE]}/${res[$R_ID]}/termproxy -XPOST)"
   port=$(echo $data | jq --raw-output .data.port)
   ticket=$(echo $data | jq --raw-output .data.ticket)

   cache=$(grep "^lnw " "$CACHE")
   token="$(echo $cache | cut -d ' ' -f 3)"
   cookie="$(echo $cache | cut -d ' ' -f 4-)"

   curl --get --include --no-buffer --insecure -H "Connection: Upgrade" \
      -H "Upgrade: websocket" -H "Sec-WebSocket-Version: 13" \
      -H "Sec-WebSocket-Protocol: base64" -H "Sec-WebSocket-Key: test" \
      --header "CSRFPreventionToken:$token" --cookie "$cookie" \
      "https://avon.lnw.verboom.net:8006/api2/json/nodes/${res[$R_HOST]}/${res[$R_TYPE]}/${res[$R_ID]}/vncwebsocket" \
      --data-urlencode "port=$port" \
      --data-urlencode "vncticket=$ticket"
}

vm_showmultiple() {
   for (( i = 0; i < ${#result[*]}; i++)); do
      res=( ${result[$i]} )
      echo "${res[$R_CLUS]}: ${res[$R_VM]} (${res[R_ID]})"
   done
}

vm_status() {
   local vmname="$1"

   clus_find_name "$vmname"
   #find_name "lnw" "$vmname"
   test "${#result[*]}" = 0 && { echo "No matches found."; exit 1; }
   test "${#result[*]}" -gt 1 && { echo "More than one match found."; vm_showmultiple; exit 1; }
   res=( ${result[0]} )
   CURL ${res[$R_CLUS]} nodes/${res[$R_HOST]}/${res[$R_TYPE]}/${res[$R_ID]}/status/current | jq .
   test "$?" -ne "0" && message -1 "Unable to get status for $vmname"
}

vm_stat() {
   local vmname="$1"
   local int="$2"

   test "$int" = "" && int=5

   clus_find_name "$vmname"
   test "${#result[*]}" = 0 && { echo "No matches found for $vmname."; exit 1; }
   test "${#result[*]}" -gt 1 && { echo "More than one match found."; vm_showmultiple; exit 1; }
   res=( ${result[0]} )

   while test 1; do
      CURL ${res[$R_CLUS]} "nodes/${res[$R_HOST]}/${res[$R_TYPE]}" | jq -r ".data[] | select(.name | contains(\"${res[$R_VM]}\")) | [.cpu,.mem,.maxmem,.netin,.netout,.diskread,.diskwrite] | @tsv"
      sleep $int
   done | awk -vLINES=$LINES 'BEGIN { LINES--; line=LINES; 
             split("B KB MB GB TB PB EB ZB YB", B);
             split("b/s Kb/s Mb/s Gb/s Tb/s", bs);
             split("B/s KB/s MB/s GB/s TB/s", Bs);
             oldtime=systime()-1; netinold=0; netoutold=0; }
             function ppB(num) {
                s=1
                while (num > 1024 && s < 9) {
                   num /= 1024
                   s++
                }
                return(sprintf("%6.1f%s", num, B[s]));
             }
             function ppbs(num) {
                s=1;
                num=num*8;
                while (num > 1024 && s < 5) {
                   num /= 1024
                   s++
                }
                return(sprintf("%6.1f%s", num, bs[s]));
             }
             function ppBs(num) {
                s=1;
                num=num;
                while (num > 1024 && s < 5) {
                   num /= 1024
                   s++
                }
                return(sprintf("%6.1f%s", num, Bs[s]));
             }


             { if (line == LINES) {
                  printf("  cpu  -----memory------ -------network-------\n");
                  printf("   %     alloc /  max         in       out\n");
                  line=2;
               }
             }
             { newtime=systime();
               cpu=$1*100; mem=$2; memmax=$3; netin=$4; netout=$5; diskread=$6
               diskwrite=$7
               if (netinold == 0) netinold=netin;
               if (netoutold == 0) netoutold=netout;
               if (diskreadold == 0) diskreadold=diskread;
               if (diskwriteold == 0) diskwriteold=diskwrite;
               netins=(netin - netinold)/(newtime-oldtime);
               netouts=(netout - netoutold)/(newtime-oldtime);
               diskreads=(diskread - diskreadold)/(newtime-oldtime);
               diskwrites=(diskwrite - diskwriteold)/(newtime-oldtime);
               printf("%5.1f%% %s/%s %s %s\n", cpu, ppB(mem), ppB(memmax), ppbs(netins), ppbs(netouts));
               line++;
               oldtime=newtime;
               netinold=netin;
               netoutold=netout;
               diskreadold=diskread;
               diskwriteold=diskwrite;
             }'
}

# Create a container
#
# Requires:
# cluster
# network bridge + device name
# ostemplate
# vmid -> retrieve next from cluster properties
ct_create() {
   declare -A vars=(['unpriv']='1' 
                    ['boot']='0' 
                    ['tmpl']='' 
                    ['rootfs']=''
                    ['rootsize']='4' )

   vmname="$1"
   shift
   if test "${vmname/@/}" != "$vmname"; then
      cluster="${vmname/*@/}"
      vmname="${vmname/@*/}"
   else
      usage
   fi
   # Check for defaults from configuration or assign default
   for var in ${!vars[@]}; do
      tmp="$var[$cluster]"
      test "${vars[$var]}" != "" && declare "$var=${vars[$var]}"
      test "${!tmp}" != "" && declare "$var=${!tmp}"
      case "$var" in
         "tmpl")
            tmp="${var}_${!tmp}[$cluster]"
            tmpl="${!tmp}"
         ;;
      esac
   done

   while test "$#" -ne "0"; do
      if test "$1" != "${1/=/}"; then label="${1/=*/}"; else label="$1"; fi
      case "$label" in
      "tmpl") tmpl="${1/*=/}"
              tmpl="tmpl_$tmpl[$cluster]"
              tmpl="${!tmpl}"
              test "$tmpl" = "" && tmpl="${1/*=/}"
      ;;
      *) if test "${vars[$label]+abc}"; then
            declare "$label=${1/*=/}"
         else
            message -1 "Unknown argument $label"
         fi
      ;;
      esac
      shift
   done
   # Check if all variable are defined
   err=0
   for var in ${!vars[@]}; do
      test "${!var}" = "" && { message 0 "Variable $var not defined."; err=1; }
   done
   test "$err" -gt "0" && exit 1

   ctid=$(CURL lnw cluster/nextid | jq --raw-output .data)
   test "$ctid" = "" && message -1 "Unable to get free id."
   CURL lnw nodes/localhost/lxc -XPOST \
      --data-urlencode vmid=$ctid \
      --data-urlencode hostname=$vmname \
      --data-urlencode ostemplate="$tmpl" \
      --data-urlencode unprivileged="$unpriv" \
      --data-urlencode net0="name=eth0,bridge=vmbr10,ip=192.168.1.245/24,gw=192.168.1.1" \
      --data-urlencode rootfs="$rootfs:$rootsize" \
      -XPOST > /dev/null
   ret=$?
   echo $ctid
   return $ret
}

vm_destroy() {
   vmname="$1"
   clus_find_name "$vmname"
   test "${#result[*]}" = 0 && { echo "No matches found."; exit 1; }
   test "${#result[*]}" -gt 1 && { echo "More than one match found."; vm_showmultiple; exit 1; }
   res=( ${result[0]} )
   CURL ${res[$R_CLUS]} nodes/${res[$R_HOST]}/${res[$R_TYPE]}/${res[$R_ID]} -XDELETE > /dev/null
   test "$?" -ne "0" && message -1 "Unable to destroy $vmname"
   return 0
}

main() {
   unset https_proxy
   verbose=0
   graphical=0

   sanity_check "$@"
   parse_config
   parse_options "$@"
   shift $((OPTIND -1))
   cmd="$1"
   name="$2"

   case "$cmd" in
      "start"|"shutdown"|"stop"|"suspend"|"resume")
         vm_action "$@"
      ;;
      "status")
         shift
         vm_status "$@"
      ;;
      "stat")
         shift
         vm_stat "$@"
      ;;
      "term")
         shift
         vm_terminal "$@"
      ;;
      "createct")
         shift
         ct_create "$@"
      ;;
      "destroy")
         shift
         vm_destroy "$@"
      ;;
      *) usage
      ;;
   esac
}

main "$@"
