#!/bin/bash
#
# pve: commandline Proxmox Virtual Environment interface

CFG=~/.pve-find.ini
SW="jq curl socat xtigervncviewer awk"
CACHE=~/.pve-cache

declare -A COOKIE
declare -A TOKEN
TIMEOUT=1
# Login session time cache
SESSION=60
# Named indices for found information on vm
readonly R_CLUS=0 R_HOST=1 R_ID=2 R_VM=3 R_TYPE=4 R_STATE=5

# CURL <cluster> "extra args"
CURL() {
   local CMD; local data; local cookie; local token; local cache; local age
   local now; local cluster; local ret
   #CMD="curl -m $TIMEOUT --fail --silent --insecure -D/dev/null"
   CMD="curl --fail --silent --insecure -D/dev/null"

   local cluster="$1"
   shift

   if test -e "$CACHE" && grep "^$cluster"$'\t' "$CACHE" > /dev/null; then
      message 2 "$cluster: Login cookie in cache."
      now=$(date "+%s")
      cache=$(grep "^$cluster"$'\t' "$CACHE")
      age=$(echo "$cache" | cut -d$'\t' -f 2)
      if test "$(( now - age ))" -lt "$SESSION"; then
         message 2 "$cluster: Already logged in."
         token="$(echo $cache | cut -d$'\t' -f 3)"
         cookie="$(echo $cache | cut -d$'\t' -f 4- )"
      else
         sed -i "/^$cluster\t/d" "$CACHE"
         message 2 "$cluster: Cache invalid."
      fi
   fi

   if test "$cookie" = ""; then
      message 1 "$cluster: Logging in."
      data=$($CMD -d @<(cat <<<"username=${user[$cluster]}&password=${password[$cluster]}")  https://${hostname[$cluster]}:8006/api2/json/access/ticket 2> /dev/null)
      ret=$?
      test $ret -eq 7 && { message -1 "${hostname[$cluster]}: Failed to connect."; exit 1; }
      test $ret -eq 28 && { message -1 "${hostname[$cluster]}: Timed out."; exit 1; }
      test "$data" = "${data/ticket/}" && { message -1 "${hostname[$cluster]}: Unable to login."; exit 1; }
      cookie=$(echo $data | jq --raw-output '.data.ticket' | sed 's/^/PVEAuthCookie=/')
      token=$(echo $data | jq --raw-output '.data.CSRFPreventionToken')
      echo -e "$cluster\t$(date '+%s')\t$token\t$cookie" >> "$CACHE"
   fi
   $CMD --header "CSRFPreventionToken:$token" --cookie "$cookie" https://${hostname[$cluster]}:8006/api2/json/$*
   return $?
}

usage() {
   echo "Usage: pve <options> command"
   echo "Runs command over multiple nodes/clusters on containers and VM's."
   echo
   #echo "  -i      Include inactive systems."
   #echo "  -v      Be more verbose (increase every time option is used)."
   #echo "  -x      Debug mode enable."
   #echo "  -c      Connect to the console of the first system found."
   #echo "  -g      Connect to the graphical console of the first VM found."
   exit 1
}

parse_config() {
   while IFS='= ' read var val
   do
      if [[ $var == \[*] ]]
      then
          section=${var:1:-1}
      elif [[ $val ]]
      then
          declare -g -A "$var[$section]=$val"
      fi
   done < <(grep -v "^#" $CFG)
}

action() {
   cluster=$1

   #CURL="curl -m $TIMEOUT -f -s -k"
   CURL="curl  -f -s -k"

   test $verbose -eq 1 && echo "${hostname[$cluster]}: Connecting."
   data=$($CURL -d @<(cat <<<"username=${user[$cluster]}&password=${password[$cluster]}")  https://${hostname[$cluster]}:8006/api2/json/access/ticket)
   ret=$?
   test $ret -eq 7 && { test $verbose -eq 1 && echo "${hostname[$cluster]}: Failed to connect."; exit 1; }
   test $ret -eq 28 && { test $verbose -eq 1 && echo "${hostname[$cluster]}: Timed out."; exit 1; }
   test "$data" = "${data/ticket/}" && { echo "${hostname[$cluster]}: Unable to login."; exit 1; }

   cookie=$(echo $data | jq --raw-output '.data.ticket' | sed 's/^/PVEAuthCookie=/')
   token="CSRFPreventionToken: $(echo $data | jq --raw-output '.data.CSRFPreventionToken')"

   CURL="$CURL -S -b $cookie"

   # port remains open for about 10 seconds
   curl -s -D/dev/stderr -k -H "$token" -b "$cookie" -XPOST https://${hostname[$cluster]}:8006/api2/json/nodes/avon/qemu/200/vncproxy | jq .
   xtigervncviewer avon:5900
}

message() {
   local level=$1
   local msg="$2"
   if test "$level" -lt 0; then
      ( >&2 echo "$msg" ) > /dev/null 
   else
      test "$verbose" -ge "$level" && ( >&2 echo "$msg" ) > /dev/null 
   fi
}

find_name() {
   cluster=$1
   name=$2
   local nodes; local node; local data; local result

   unset clause
   #test $active -eq 1 && clause="and .status == \"running\""

   nodes=$(CURL $cluster nodes/ | jq -r ".data[] | .node")
   for node in $nodes
   do
      data="$(CURL $cluster nodes/$node/lxc/) $(CURL $cluster nodes/$node/qemu/)"
      result=$(echo $data | jq -r ".data[] | select((.name  | contains(\"$name\")) $clause) | \"$node \(.vmid) \(.name) \(.type // \"qemu\") \(.status)\"")
      if test "$result" != ""; then
         echo "$cluster $result"
      fi
   done
}

sanity_check() {
   err=0

   ! test -f $CFG && { echo "No config file found ($CFG)."; err=1; }

   test $err -eq 0 && test $(stat -c %a $CFG) -gt 600 && { echo "Unsafe permissions on config file."; err=1; }

   for name in $SW
   do
      if ! which $name > /dev/null 2>&1
      then
         missing="$missing $name"
         err=1
      fi
   done
   test "$missing" != "" && echo "Missing required software to run script:$missing"

   test $# -lt 1 && { echo "At least one argument required."; err=1; }

   test $err -ne 0 && usage
}

parse_options() {
   while getopts :igcvx opt
   do
      case $opt in
         v) verbose=$(( verbose + 1 ))
         ;;
         c) connect=1
         ;;
         g) graphical=1
         ;;
         i) active=0
         ;;
         x) set -x
         ;;
         \?) echo "Unknowing options: -$OPTARG"
             usage
         ;;
      esac
   done
   shift $((OPTIND -1))
   cmd="$1"
   name="$2"
}

vnc() {
   server=$1
   type=$2
   vmid=$3
   test $verbose -eq 1 && echo "Connecting to server $server for $name..."

   port=$((netstat -atn | awk '{printf "%s\n%s\n", $4, $4}' | grep -oE '[0-9]*$'; seq 32768 61000) | sort -n | uniq -u | head -n 1)
   socat TCP-LISTEN:$port,bind=127.0.0.1 exec:"ssh root@$server qm vncproxy $vmid" &
   xtigervncviewer localhost:$port
}

clus_find_name() {
   local line
   local cluster
   local ret

   result=()
   while read line; do
      if test "${line:0:1}" = "#"; then
         ret=( ${line:1} )
      else if test "$line" != ""; then
            result+=( "$line" )
         fi
      fi
   done < <( for cluster in ${!hostname[*]}; do
                find_name $cluster $name & 
                pids+=( $! )
             done 
             ret=0
             for pid in ${pids[*]}; do
                wait $pid
                ret=$(( ret + $? ))
             done
             echo "#$ret"
           )
   return $ret
}

vm_status() {
   local action="$1"
   local vmname="$2"

   clus_find_name "$vmname"
   test "${#result[*]}" = 0 && { echo "No matches found."; exit 1; }
   test "${#result[*]}" -gt 1 && { echo "More than one match found."; exit 1; }
   res=( ${result[0]} )
   CURL ${res[$R_CLUS]} nodes/${res[$R_HOST]}/${res[$R_TYPE]}/${res[$R_ID]}/status/$action -XPOST > /dev/null
   test "$?" -ne "0" && message -1 "Unable to $action $vmname"
}

# Try and see if we can open a websocket and use it as a terminal
#
# https://git.proxmox.com/?p=pve-xtermjs.git;a=blob;f=src/www/main.js;h=62ec1c1846dc2cccd39ae3cbe5f7345ac74e58ed;hb=refs/heads/master
# https://gist.github.com/htp/fbce19069187ec1cc486b594104f01d0
#
# socketURL = protocol + location.hostname + ((location.port) ? (':' + location.port) : '') + '/api2/json' + url + '/vncwebsocket?port=' + port + '&vncticket=' + encodeURIComponent(ticket);
#
vm_terminal() {
   local vmname="$1"

   clus_find_name "$vmname"
   test "${#result[*]}" = 0 && { echo "No matches found."; exit 1; }
   test "${#result[*]}" -gt 1 && { echo "More than one match found."; exit 1; }
   res=( ${result[0]} )
   data="$(CURL ${res[$R_CLUS]} nodes/${res[$R_HOST]}/${res[$R_TYPE]}/${res[$R_ID]}/termproxy -XPOST)"
   port=$(echo $data | jq --raw-output .data.port)
   ticket=$(echo $data | jq --raw-output .data.ticket)

   cache=$(grep "^lnw " "$CACHE")
   token="$(echo $cache | cut -d ' ' -f 3)"
   cookie="$(echo $cache | cut -d ' ' -f 4-)"

   # Protocol: base64
   # /usr/bin/perl /usr/bin/termproxy 5900 --path /vms/110 --perm VM.Console -- /usr/bin/dtach -A /var/run/dtach/vzctlconsole110 -r winch -z lxc-console -n 110 -e -1
   # Protocol: binary
   # /usr/bin/perl /usr/bin/termproxy 5900 --path /vms/110 --perm VM.Console -- /usr/bin/dtach -A /var/run/dtach/vzctlconsole110 -r winch -z lxc-console -n 110 -e -1
   # Geeft console: /usr/bin/dtach -A /var/run/dtach/vzctlconsole110 -r winch -z lxc-console -n 110 -e -1

   curl --get --include --no-buffer --insecure -H "Connection: Upgrade" -H "Upgrade: websocket" -H "Sec-WebSocket-Version: 13" -H "Sec-WebSocket-Protocol: base64" -H "Sec-WebSocket-Key: test" --header "CSRFPreventionToken:$token" --cookie "$cookie" "https://avon.lnw.verboom.net:8006/api2/json/nodes/${res[$R_HOST]}/${res[$R_TYPE]}/${res[$R_ID]}/vncwebsocket" --data-urlencode "port=$port" --data-urlencode "vncticket=$ticket"
}

vm_stat() {
   local vmname="$1"

   clus_find_name "$vmname"
   #find_name "lnw" "$vmname"
   test "${#result[*]}" = 0 && { echo "No matches found."; exit 1; }
   test "${#result[*]}" -gt 1 && { echo "More than one match found."; exit 1; }
   res=( ${result[0]} )
   CURL ${res[$R_CLUS]} nodes/${res[$R_HOST]}/${res[$R_TYPE]}/${res[$R_ID]}/status/current | jq .
   test "$?" -ne "0" && message -1 "Unable to $action $vmname"
}

main() {
   unset https_proxy
   verbose=0
   graphical=0

   sanity_check "$@"
   parse_config
   parse_options "$@"

   case "$cmd" in
      "start"|"shutdown"|"stop"|"suspend"|"resume")
         vm_status "$cmd" "$name"
      ;;
      "status")
         vm_stat "$name"
      ;;
      "term")
         vm_terminal "$name"
      ;;
      *) usage
      ;;
   esac
}

main "$@"
